import okhttp3.*
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.*
import java.io.IOException

// --- MODÈLES DE DONNÉES ---

/**
 * Réponse lors de l'échange ou du rafraîchissement de jeton
 */
data class StravaTokenResponse(
    val token_type: String,
    val access_token: String,
    val expires_at: Long,
    val expires_in: Int,
    val refresh_token: String,
    val athlete: AthleteProfile?
)

/**
 * Profil complet de l'athlète
 */
data class AthleteProfile(
    val id: Long,
    val username: String?,
    val firstname: String?,
    val lastname: String?,
    val city: String?,
    val state: String?,
    val country: String?,
    val sex: String?,
    val weight: Float?,
    val bio: String?,
    val follower_count: Int?,
    val friend_count: Int?,
    val ftp: Int?,
    val shoes: List<Gear>?,
    val bikes: List<Gear>?
)

data class Gear(
    val id: String,
    val name: String,
    val distance: Float,
    val primary: Boolean
)

/**
 * Activité détaillée
 */
data class ActivityDetailed(
    val id: Long,
    val name: String,
    val distance: Float,
    val moving_time: Int,
    val elapsed_time: Int,
    val total_elevation_gain: Float,
    val type: String,
    val start_date: String,
    val average_speed: Float,
    val max_speed: Float,
    val average_heartrate: Float?,
    val max_heartrate: Float?,
    val device_name: String?,
    val calories: Float?
)

// --- SERVICE API ---

interface StravaApiService {

    @POST("oauth/token")
    fun refreshAccessToken(
        @Query("client_id") clientId: Int,
        @Query("client_secret") clientSecret: String,
        @Query("refresh_token") refreshToken: String,
        @Query("grant_type") grantType: String = "refresh_token"
    ): retrofit2.Call<StravaTokenResponse>

    @GET("athlete")
    suspend fun getAuthenticatedAthlete(): AthleteProfile

    @GET("athlete/activities")
    suspend fun getActivities(
        @Query("before") before: Long? = null,
        @Query("after") after: Long? = null,
        @Query("page") page: Int = 1,
        @Query("per_page") perPage: Int = 30
    ): List<ActivityDetailed>

    @GET("gear/{id}")
    suspend fun getGear(@Path("id") gearId: String): Gear
}

// --- GESTION DE L'AUTHENTIFICATION ---

/**
 * Stockage simple pour les jetons (À remplacer par une solution persistante comme SharedPreferences/DataStore)
 */
object TokenStorage {
    var accessToken: String? = null
    var refreshToken: String? = null
    var expiresAt: Long = 0
}

/**
 * Authenticator OkHttp : Intercepte les erreurs 401 et rafraîchit le token
 */
class StravaAuthenticator(
    private val clientId: Int,
    private val clientSecret: String,
    private val apiService: StravaApiService
) : Authenticator {
    
    override fun authenticate(route: Route?, response: Response): Request? {
        // Éviter les boucles infinies si le rafraîchissement échoue lui aussi
        if (response.count401() > 2) return null

        synchronized(this) {
            val currentRefreshToken = TokenStorage.refreshToken ?: return null
            
            // Appel synchrone pour obtenir un nouveau token
            val tokenResponse = apiService.refreshAccessToken(
                clientId, clientSecret, currentRefreshToken
            ).execute()

            if (tokenResponse.isSuccessful && tokenResponse.body() != null) {
                val newTokens = tokenResponse.body()!!
                
                // Sauvegarde des nouveaux jetons
                TokenStorage.accessToken = newTokens.access_token
                TokenStorage.refreshToken = newTokens.refresh_token
                TokenStorage.expiresAt = newTokens.expires_at

                // Re-tentative de la requête initiale avec le nouveau token
                return response.request.newBuilder()
                    .header("Authorization", "Bearer ${newTokens.access_token}")
                    .build()
            }
        }
        return null
    }

    private fun Response.count401(): Int {
        var result = 1
        var r = priorResponse
        while (r != null) {
            result++
            r = r.priorResponse
        }
        return result
    }
}

/**
 * Intercepteur pour ajouter le Header Authorization à chaque requête
 */
class AuthInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest = chain.request()
        val token = TokenStorage.accessToken

        // On n'ajoute pas le header pour l'endpoint d'authentification
        if (originalRequest.url.encodedPath.contains("oauth/token") || token == null) {
            return chain.proceed(originalRequest)
        }

        val authenticatedRequest = originalRequest.newBuilder()
            .header("Authorization", "Bearer $token")
            .build()
        
        return chain.proceed(authenticatedRequest)
    }
}

// --- CLIENT FINAL ---

class StravaClient(private val clientId: Int, private val clientSecret: String) {
    
    val api: StravaApiService

    init {
        val logging = HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.HEADERS
        }

        // 1. Création d'un service temporaire pour l'authenticator
        val tempRetrofit = Retrofit.Builder()
            .baseUrl("https://www.strava.com/api/v3/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val tempService = tempRetrofit.create(StravaApiService::class.java)

        // 2. Client OkHttp avec Interceptor et Authenticator
        val okHttpClient = OkHttpClient.Builder()
            .addInterceptor(AuthInterceptor())
            .addInterceptor(logging)
            .authenticator(StravaAuthenticator(clientId, clientSecret, tempService))
            .build()

        // 3. Instance Retrofit finale
        val retrofit = Retrofit.Builder()
            .baseUrl("https://www.strava.com/api/v3/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()

        api = retrofit.create(StravaApiService::class.java)
    }

    /**
     * URL à générer pour que l'utilisateur valide TOUTES les permissions
     */
    fun getAuthorizationUrl(redirectUri: String): String {
        val scopes = "read,read_all,profile:read_all,profile:write,activity:read,activity:read_all,activity:write"
        return "https://www.strava.com/oauth/authorize" +
                "?client_id=$clientId" +
                "&redirect_uri=$redirectUri" +
                "&response_type=code" +
                "&scope=$scopes"
    }
}

